<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://blog.newnius.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":false,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":"livere","storage":true,"lazyload":false,"nav":null,"activeClass":"livere"},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="AbstractIn this big data time, high performance distributed systems are required to process the large volumn of data. However, it is not easy to organize plenty of nodes. One of the significant proble">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang implementation of the Raft consensus protocol (1)">
<meta property="og:url" content="https://blog.newnius.com/golang-implementation-of-the-raft-consensus-protocol-1.html">
<meta property="og:site_name" content="鱼喃">
<meta property="og:description" content="AbstractIn this big data time, high performance distributed systems are required to process the large volumn of data. However, it is not easy to organize plenty of nodes. One of the significant proble">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://image.newnius.com/images/2019/11/30/69d221770d3cd1c9d61d1b8bf6372f1f.md.png">
<meta property="og:image" content="https://image.newnius.com/images/2019/11/30/f30ee428c3663d7aa6ddba8aba80c3f1.png">
<meta property="article:published_time" content="2017-11-26T14:24:12.000Z">
<meta property="article:modified_time" content="2020-03-03T15:59:47.786Z">
<meta property="article:author" content="Newnius">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image.newnius.com/images/2019/11/30/69d221770d3cd1c9d61d1b8bf6372f1f.md.png">

<link rel="canonical" href="https://blog.newnius.com/golang-implementation-of-the-raft-consensus-protocol-1.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Golang implementation of the Raft consensus protocol (1) | 鱼喃</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-51090562-2"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-51090562-2');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/sitemap.xml" title="鱼喃" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">鱼喃</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">听！布鲁布鲁，大鱼又在那叨叨了</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-toys">

    <a href="/my-works/" rel="section"><i class="fa fa-fw fa-tree"></i>Toys</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="fa fa-fw fa-link"></i>Links</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about-me/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-search">

    <a href="https://www.google.com.hk/search?q=site:blog.newnius.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-search"></i>Search</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://blog.newnius.com/golang-implementation-of-the-raft-consensus-protocol-1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Newnius">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="鱼喃">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          Golang implementation of the Raft consensus protocol (1)
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-11-26 22:24:12" itemprop="dateCreated datePublished" datetime="2017-11-26T22:24:12+08:00">2017-11-26</time>
            </span>

          
            <span class="post-meta-item" title="Views" id="pvcounter_container_page_pv">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="cr_count_pv">99+</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>In this big data time, high performance distributed systems are required to process the large volumn of data. However, it is not easy to organize plenty of nodes. One of the significant problems is distributed consensus, which means every node in the cluster will eventually reach a consensus without any conflict.</p>
<p>Raft is a distributed consensus algorithm which has been proved workable. This expriment mainly focus on designing and implementing leader election described in rart algorithm.</p>
<a id="more"></a>

<h3 id="keywords"><a href="#keywords" class="headerlink" title="keywords"></a>keywords</h3><p>Distributed Consensus, Leader Election, Log Replication</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Before Raft, (multi-)Paxos has been treated as an industry standard for a long time. However, even with the help of Paxos, we still find it hard to build up a reliable distributed system.</p>
<p>Just as the comment from Chubby implementers:</p>
<blockquote>
<p>There are significant gaps between the description of the Paxos algorithm and the needs of a real-world system…. the final system will be based on an unproven protocol.</p>
</blockquote>
<p>Paxos is rather difficult to implement mainly because it is not easy to understand for those who are not mathematicians.</p>
<p>Then Raft came out, which has a good understandability. Compared with Paxos, there are smaller state space achieved by reducing states. Also, Raft decomposes the problem into leader election, log replication, safety and membership changes, instead of treating them as a total of mess.</p>
<p>To further understand distributed consensus, this expriment tries to implement the first section <em>leader election</em> in Raft and leave the rest parts in the following expriments.</p>
<h2 id="Design-amp-Implementation"><a href="#Design-amp-Implementation" class="headerlink" title="Design &amp; Implementation"></a>Design &amp; Implementation</h2><p>The language we use in this expriment is Go 1.9.</p>
<h3 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h3><p>There are some states such as current term, logs, role of node that have to be stored and shared across the threads, so we design a structure called <em>Raft</em>. Among the variables, <em>currentTerm</em>, <em>votedFor</em> and <em>logs</em> are required to be persisted while the rest are volatile.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu        sync.Mutex</span><br><span class="line">	peers     []*labrpc.ClientEnd</span><br><span class="line">	persister *Persister</span><br><span class="line">	me        <span class="keyword">int</span> <span class="comment">// index into peers[]</span></span><br><span class="line"></span><br><span class="line">	currentTerm <span class="keyword">int</span></span><br><span class="line">	votedFor <span class="keyword">int</span></span><br><span class="line">	logs []<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	commitIndex <span class="keyword">int</span></span><br><span class="line">	lastApplied <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	nextIndex []<span class="keyword">int</span></span><br><span class="line">	matchIndex []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	role <span class="keyword">int</span> <span class="comment">//0-follower, 1-candidate, 2-leader</span></span><br><span class="line">	electionTimeout time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Initialization-amp-main-loop"><a href="#Initialization-amp-main-loop" class="headerlink" title="Initialization &amp; main loop"></a>Initialization &amp; main loop</h3><p>When a node starts up, it firstly initializes the Raft object, generates election timeout and heart beat timeout randomlly. Then, it reads persisted data which are stored before last crash. After initailazation, it comes to the infinite main loop. In the main loop, the node sleeps for a certain time, when it wakes up, it checks whether he is the leader or the leader has connected with him not long ago (within <em>heartBeatTimeout</em>). If not, it increases the <em>currentTerm</em> and starts a new election in another new thread.</p>
<p>There are two things to mention. The first is random <em>electionTimeout</em>. Same <em>electionTimeout</em> may cause infinite elections if each node starts up at nearly the same time. Different timeout can help reduce the conflicts. To further reduce the conflicts, the node will re-generate <em>electionTimeout</em> randomlly before an election for some nodes may have same <em>electionTimeout</em> and may cause infinite elections especially in small clusters. The other is fake sleep. There is no easy approaches to extend the sleep time when the thread is in sleep. So the node will wake up earlier than expected. To emulate the delay, when the node wakes up, we will compare the time last heart beat arrived with current time, if the duration is smaller than <em>electionTimeout</em>, we make the node resume sleeping for the duration.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/* initialization */</span></span><br><span class="line">	rf := &amp;Raft&#123;&#125;</span><br><span class="line">	rf.peers = peers</span><br><span class="line">	rf.persister = persister</span><br><span class="line">	rf.me = me</span><br><span class="line">	rf.electionTimeout = time.Duration(rand.Intn(<span class="number">100</span>) + <span class="number">100</span>) * time.Millisecond</span><br><span class="line">	rf.heartBeatTimeout = time.Duration(rand.Intn(<span class="number">50</span>) + <span class="number">50</span>) * time.Millisecond</span><br><span class="line">	rf.counter = <span class="number">0</span></span><br><span class="line">	rf.lastHeart = time.Now()</span><br><span class="line">	rf.heartBeatTicker = time.NewTicker(rf.heartBeatTimeout)</span><br><span class="line">	rf.role = <span class="number">0</span> <span class="comment">//start in follower state</span></span><br><span class="line">	rf.commitIndex = <span class="number">0</span></span><br><span class="line">	rf.lastApplied = <span class="number">0</span></span><br><span class="line">	<span class="comment">// initialize from state persisted before a crash</span></span><br><span class="line">	rf.readPersist(persister.ReadRaftState())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//main loop</span></span><br><span class="line">		<span class="keyword">for</span> ;;&#123;</span><br><span class="line">			<span class="comment">/* wait timeout */</span></span><br><span class="line">			time.Sleep(rf.electionTimeout - time.Since(rf.lastHeart))</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> rf.role != <span class="number">2</span> &amp;&amp; time.Since(rf.lastHeart) &gt;= rf.electionTimeout &#123;</span><br><span class="line">				rf.mu.Lock()</span><br><span class="line">				rf.electionTimeout = time.Duration(rand.Intn(<span class="number">100</span>) + <span class="number">100</span>) * time.Millisecond</span><br><span class="line">				rf.currentTerm ++</span><br><span class="line">				rf.votedFor = rf.me</span><br><span class="line">				rf.role = <span class="number">1</span></span><br><span class="line">				rf.persist()</span><br><span class="line">				rf.mu.Unlock()</span><br><span class="line">				rf.doVote()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* sleep at most electionTimeout duration */</span></span><br><span class="line">			<span class="keyword">if</span> time.Since(rf.lastHeart) &gt;= rf.electionTimeout &#123;</span><br><span class="line">				rf.lastHeart = time.Now()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> rf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://image.newnius.com/image/beAX" target="_blank" rel="noopener"><img src="https://image.newnius.com/images/2019/11/30/69d221770d3cd1c9d61d1b8bf6372f1f.md.png" alt="69d221770d3cd1c9d61d1b8bf6372f1f.md.png"></a></p>
<h3 id="Election"><a href="#Election" class="headerlink" title="Election"></a>Election</h3><p>In the election, a node will exchange messages with other nodes. Two typical are request and response message of vote request. The term will keep until the leader crashed and another election are be made.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RequestVoteArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	Term <span class="keyword">int</span></span><br><span class="line">	CandidateId <span class="keyword">int</span></span><br><span class="line">	LastLogIndex <span class="keyword">int</span></span><br><span class="line">	LastLogTerm <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RequestVoteReply <span class="keyword">struct</span> &#123;</span><br><span class="line">	Term <span class="keyword">int</span></span><br><span class="line">	VoteGranted <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The election performs as follows. The node who wants to be the leader firstly switch to candidate state and send a <em>RequestVote</em> call to other nodes, attaching the term and logd infomation. The called node will compare the <em>Term</em> with its <em>currentTerm</em>, it <em>Term</em> is smaller, it simply refuse the request. Otherwise, the node will check whether if the logs of candidate is at least up to date with its <em>logs</em>. If all pass, it grants the request and switch to follower state and set <em>votedFor</em> to <em>candidateId</em>. Whatever the result is, if higher <em>Term</em> detected, the node will update <em>currentTerm</em> to <em>Term</em> and switch to follower state. In this expriment, there will be no logs appended, so the log checks is skipped.</p>
<p>When a majority of nodes agree the request, it switches to leader state and starts to send heart beat message to each node periodically until it is no longer a leader. If the heart beat reply or vote request reply reports a higher term, it will switch to follower state whatever the state is.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">doVote</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> agreed <span class="keyword">int64</span> = <span class="number">1</span></span><br><span class="line">	index := rf.commitIndex</span><br><span class="line">	term := <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> index != <span class="number">0</span> &#123;</span><br><span class="line">		term = rf.logs[index - <span class="number">1</span>][<span class="string">"term"</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt; <span class="built_in">len</span>(rf.peers);i++&#123;</span><br><span class="line">		<span class="keyword">if</span> i != rf.me &#123;</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="keyword">int</span>, currTerm <span class="keyword">int</span>, index <span class="keyword">int</span>, term <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">				args := RequestVoteArgs&#123;Term: currTerm, CandidateId:rf.me, LastLogIndex:index, LastLogTerm:term&#125;</span><br><span class="line">				reply := RequestVoteReply&#123;&#125;</span><br><span class="line">				ok := rf.sendRequestVote(peer, args, &amp;reply)</span><br><span class="line">				rf.mu.Lock()</span><br><span class="line">				<span class="keyword">if</span> ok &amp;&amp; args.Term == rf.currentTerm &amp;&amp; rf.role == <span class="number">1</span>&#123;</span><br><span class="line">					atomic.AddInt64(&amp;agreed, <span class="number">1</span>)</span><br><span class="line">					<span class="keyword">if</span> (<span class="keyword">int</span>(agreed) * <span class="number">2</span> &gt; <span class="built_in">len</span>(rf.peers)) &#123;</span><br><span class="line">						rf.role = <span class="number">2</span></span><br><span class="line">						<span class="comment">/* persist state */</span></span><br><span class="line">						rf.persist()</span><br><span class="line">						<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(peers);i++ &#123;</span><br><span class="line">							rf.nextIndex = <span class="built_in">append</span>(rf.nextIndex, <span class="built_in">len</span>(rf.logs) + <span class="number">1</span>)</span><br><span class="line">							rf.matchIndex = <span class="built_in">append</span>(rf.matchIndex, <span class="number">0</span>)</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">go</span> rf.doSubmit()</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				rf.mu.Unlock()</span><br><span class="line">			&#125;(i, rf.currentTerm, index, term)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">sendRequestVote</span><span class="params">(server <span class="keyword">int</span>, args RequestVoteArgs, reply *RequestVoteReply)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	ok := rf.peers[server].Call(<span class="string">"Raft.RequestVote"</span>, args, reply)</span><br><span class="line">	<span class="keyword">if</span> reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">		rf.mu.Lock()</span><br><span class="line">		rf.currentTerm = reply.Term</span><br><span class="line">		rf.role = <span class="number">0</span></span><br><span class="line">		rf.votedFor = <span class="number">-1</span></span><br><span class="line">		rf.persist()</span><br><span class="line">		rf.mu.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ok &amp;&amp; reply.VoteGranted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">RequestVote</span><span class="params">(args RequestVoteArgs, reply *RequestVoteReply)</span></span> &#123;</span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">		reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* whatever, if higher term found, switch to follower */</span></span><br><span class="line">		<span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123;</span><br><span class="line">			rf.role = <span class="number">0</span></span><br><span class="line">			rf.votedFor = <span class="number">-1</span></span><br><span class="line">			rf.currentTerm = args.Term</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* check log first, there is no requests in this expriment, so skip the details */</span></span><br><span class="line">		<span class="keyword">if</span> (rf.votedFor == <span class="number">-1</span> || rf.votedFor == args.CandidateId) &#123;</span><br><span class="line">			reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">			rf.role = <span class="number">0</span></span><br><span class="line">			rf.votedFor = args.CandidateId</span><br><span class="line">			rf.lastHeart = time.Now()</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	rf.persist()</span><br><span class="line">	reply.Term = rf.currentTerm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Heart-beat"><a href="#Heart-beat" class="headerlink" title="Heart beat"></a>Heart beat</h3><p>The heart beat message can be empty, but for conpatible with  following expriments, we set several variables in the request and response messages. As mentioned above, the the reply message reports a higher <em>Term</em>, the leader will immediatelly stop the heart beat and switch to follower state. When a node receives a heart beat message, it will update <em>lastHeart</em> to <em>time.Now()</em> to delay wake up.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AppendEntriesArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	Term <span class="keyword">int</span></span><br><span class="line">	LeaderId <span class="keyword">int</span></span><br><span class="line">	PrevLogIndex <span class="keyword">int</span></span><br><span class="line">	PrevLogTerm <span class="keyword">int</span></span><br><span class="line">	Entries []<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">	LeaderCommit <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AppendEntriesReply <span class="keyword">struct</span> &#123;</span><br><span class="line">	Term <span class="keyword">int</span></span><br><span class="line">	Success <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">AppendEntries</span><span class="params">(args AppendEntriesArgs, reply *AppendEntriesReply)</span></span> &#123;</span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">		reply.Success = <span class="literal">false</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123;</span><br><span class="line">		reply.Success = <span class="literal">true</span></span><br><span class="line">		rf.currentTerm = args.Term</span><br><span class="line">		rf.role = <span class="number">0</span></span><br><span class="line">		rf.votedFor = args.LeaderId</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		reply.Success = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> reply.Success &#123;</span><br><span class="line">		rf.lastHeart = time.Now()</span><br><span class="line">	&#125;</span><br><span class="line">	reply.Term = rf.currentTerm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">sendAppendEntries</span><span class="params">(server <span class="keyword">int</span>, args AppendEntriesArgs, reply *AppendEntriesReply)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	ok := rf.peers[server].Call(<span class="string">"Raft.AppendEntries"</span>, args, reply)</span><br><span class="line">	<span class="keyword">if</span> reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">		rf.mu.Lock()</span><br><span class="line">		rf.currentTerm = reply.Term</span><br><span class="line">		rf.role = <span class="number">0</span></span><br><span class="line">		rf.votedFor = <span class="number">-1</span></span><br><span class="line">		rf.persist()</span><br><span class="line">		rf.mu.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ok &amp;&amp; reply.Success</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">doSubmit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/* ensure only one thread is running */</span></span><br><span class="line">	<span class="keyword">if</span> atomic.AddInt64(&amp;rf.counter, <span class="number">1</span>) &gt; <span class="number">1</span> &#123;</span><br><span class="line">		atomic.AddInt64(&amp;rf.counter, <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">range</span> rf.heartBeatTicker.C &#123;</span><br><span class="line">		<span class="keyword">if</span> rf.role != <span class="number">2</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt; <span class="built_in">len</span>(rf.peers);i++&#123;</span><br><span class="line">			<span class="keyword">if</span> i != rf.me &#123;</span><br><span class="line">				<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">					rf.mu.Lock()</span><br><span class="line">					index := rf.nextIndex[peer]</span><br><span class="line">					term := <span class="number">0</span></span><br><span class="line">					entries := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">					args := AppendEntriesArgs&#123;Term: rf.currentTerm, LeaderId:rf.me, PrevLogIndex:index - <span class="number">1</span>, PrevLogTerm:term, Entries:entries, LeaderCommit:rf.commitIndex&#125;</span><br><span class="line">					reply := AppendEntriesReply&#123;&#125;</span><br><span class="line">					rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">					ok := rf.sendAppendEntries(peer, args, &amp;reply)</span><br><span class="line">				&#125;(i)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	atomic.AddInt64(&amp;rf.counter, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>During the implemention, we found some inadequates in Raft, one of them is the strategy of processing vote request. It says if a node meets a higher term, it will switch to follower state. Assume a cluster with three nodes A, B and C. A is the leader in term 1, and shortly B encounters a network failure whose duration is longer than <em>electionTimeout</em>, thus B will start a new term and request for votes. When the network resumes, A and C will detect a higher term from B’s request and according the Raft algorithm they will stop this term and make a new election. However, the cluster works well and a new election is unnecessary. This means in a large cluster, even if only a single node restarts, the whole cluster has to be re-built. This will reduce the performance of the cluster to a large extent especially when the cluster is large.</p>
<p>Raft uses this strategy to make sure that leader can switch to follower state. But we can add another logic to realize that by counting followers. If a leader finds not a majority of nodes replies the heart beat message and it lasts longer than <em>electionTimeout</em>, it then switches to follower state and starts a new election.</p>
<h2 id="Validation"><a href="#Validation" class="headerlink" title="Validation"></a>Validation</h2><p>There two test cases <em>TestInitialElection</em> and <em>TestReElection</em> are designed to test the correctness of the system. Run the tests many times and the result shows our system passes all the test cases successfully.</p>
<p><a href="https://image.newnius.com/image/ba4m" target="_blank" rel="noopener"><img src="https://image.newnius.com/images/2019/11/30/f30ee428c3663d7aa6ddba8aba80c3f1.png" alt="f30ee428c3663d7aa6ddba8aba80c3f1.png"></a></p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>This expriment mainly focus on implementing the leader election part of Raft algorithm. The result shows that the cluster quickly generates a leader and remains the normal state until a failure, and after the failure the cluster can re-generate a new leader in a short time. This expriment proves the reliablity of Raft algorithm in another way.</p>
<p><em>* The full and up-to-date code is hosted at <a href="https://github.com/newnius/code2go/tree/master/src/raft" target="_blank" rel="noopener">https://github.com/newnius/code2go/tree/master/src/raft</a></em></p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] Ongaro D, Ousterhout J K. In search of an understandable consensus algorithm[C]//USENIX Annual Technical Conference. 2014: 305-319.</p>
<p>[2] <a href="https://my5353.com/Btype" target="_blank" rel="noopener">Raft</a></p>
<p>[3] <a href="https://gobyexample.com/atomic-counters" target="_blank" rel="noopener">Go by Example: Atomic Counters</a></p>
<p>[4] <a href="https://gobyexample.com/non-blocking-channel-operations" target="_blank" rel="noopener">Go by Example: Non-Blocking Channel Operations</a></p>
<p>[5] <a href="https://mmcgrana.github.io/2012/09/go-by-example-timers-and-tickers.html" target="_blank" rel="noopener">Go by Example: Timers and Tickers</a></p>
<p>[6] <a href="https://github.com/golang/go/issues/14038" target="_blank" rel="noopener">time: Timer.Reset is not possible to use correctly</a></p>
<p>[7] <a href="https://my5353.com/OhAE6" target="_blank" rel="noopener">论golang Timer Reset方法使用的正确姿势</a></p>
<p>[8] <a href="https://my5353.com/qWEm6" target="_blank" rel="noopener">Go Channel 详解</a></p>
<p>[9] <a href="https://my5353.com/n7Muy" target="_blank" rel="noopener">Go 语言切片(Slice)</a></p>
<p>[10] <a href="https://wizardforcel.gitbooks.io/w3school-go/content/20-5.html" target="_blank" rel="noopener">Go 语言函数方法</a></p>
<p>[11] <a href="https://my5353.com/AoX2a" target="_blank" rel="noopener">Golang初学者易犯的三种错误</a></p>
<p>[12] <a href="https://github.com/go-lang-plugin-org/go-lang-idea-plugin/issues/2897" target="_blank" rel="noopener">Not able to install go lang plugin on intellij 2017.2 community edition</a></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Newnius
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://blog.newnius.com/golang-implementation-of-the-raft-consensus-protocol-1.html" title="Golang implementation of the Raft consensus protocol (1)">https://blog.newnius.com/golang-implementation-of-the-raft-consensus-protocol-1.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Go/" rel="tag"># Go</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/implement-ntp-protocol-with-golang-rpc.html" rel="prev" title="Implement NTP protocol with golang RPC">
      <i class="fa fa-chevron-left"></i> Implement NTP protocol with golang RPC
    </a></div>
      <div class="post-nav-item">
    <a href="/how-to-quickly-setup-a-hadoop-cluster-in-docker.html" rel="next" title="How to quickly setup a Hadoop cluster in Docker">
      How to quickly setup a Hadoop cluster in Docker <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="isso-thread" data-id="city" data-uid="https://comment.newnius.com/"></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Newnius"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Newnius</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">153</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/newnius" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;newnius" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:newnius.cn@gmail.com" title="E-Mail → mailto:newnius.cn@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Newnius</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a>
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        


<div class="pv-counter">
  <script async src="https://cdn.newnius.com/ana/ea.js"></script>
    <span class="post-meta-item" id="pvcounter_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span class="cr_count_site_uv">99+</span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="pvcounter_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span class="cr_count_site_pv">99+</span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

<script data-isso="https://comment.newnius.com/"
        data-isso-css="true"
        data-isso-lang="en"
        data-isso-reply-to-self="true"
        data-isso-require-author="false"
        data-isso-require-email="false"
        data-isso-max-comments-top="50"
        data-isso-max-comments-nested="10"
        data-isso-reveal-on-click="50"
        data-isso-avatar="true"
        data-isso-reply-notifications="true"
        data-isso-avatar-bg="#f0f0f0"
        data-isso-avatar-fg="#9abf88 #5698c4 #e279a3 #9163b6 ..."
        data-isso-vote="true"
        data-isso-vote-levels="-5,5"
        data-isso-feed="false"
        src="https://comment.newnius.com/js/embed.min.js"></script>

<style>
/* * Hide Website boxes in Isso comments */
#isso-thread input[name="website"] {
    display:none;
}
</style>

</body>
</html>
